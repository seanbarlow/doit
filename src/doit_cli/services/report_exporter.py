"""Report exporter service for spec analytics.

Provides export functionality for analytics reports in
Markdown and JSON formats.
"""

import json
from datetime import datetime
from pathlib import Path
from typing import Optional

from ..models.analytics_models import AnalyticsReport


class ReportExporter:
    """Exporter for analytics reports.

    Generates formatted reports in various output formats
    suitable for sharing or archival.
    """

    def __init__(self, report: AnalyticsReport):
        """Initialize exporter with a report.

        Args:
            report: The AnalyticsReport to export
        """
        self.report = report

    def export_markdown(self) -> str:
        """Export report as Markdown.

        Returns:
            Markdown formatted report string
        """
        lines = [
            f"# Analytics Report - {self.report.project_root.name}",
            "",
            f"**Generated**: {self.report.generated_at.strftime('%Y-%m-%d %H:%M:%S')}",
            f"**Report ID**: {self.report.report_id}",
            "",
            "---",
            "",
            "## Summary",
            "",
            f"- **Total Specs**: {self.report.total_specs}",
            f"- **Completion Rate**: {self.report.completion_pct}%",
        ]

        if self.report.cycle_stats:
            lines.append(
                f"- **Average Cycle Time**: {self.report.cycle_stats.average_days} days"
            )

        # Status breakdown
        lines.extend([
            "",
            "## Status Breakdown",
            "",
            "| Status | Count | Percentage |",
            "|--------|-------|------------|",
        ])

        total = self.report.total_specs
        for status, count in sorted(
            self.report.by_status.items(), key=lambda x: x[1], reverse=True
        ):
            pct = (count / total * 100) if total > 0 else 0
            lines.append(f"| {status.display_name} | {count} | {pct:.1f}% |")

        # Cycle time statistics
        if self.report.cycle_stats:
            stats = self.report.cycle_stats
            lines.extend([
                "",
                "## Cycle Time Statistics",
                "",
                f"Based on {stats.sample_count} completed specifications.",
                "",
                "| Metric | Value |",
                "|--------|-------|",
                f"| Average | {stats.average_days} days |",
                f"| Median | {stats.median_days} days |",
                f"| Minimum | {stats.min_days} days |",
                f"| Maximum | {stats.max_days} days |",
                f"| Std Deviation | {stats.std_dev_days} days |",
            ])

        # Velocity trends
        if self.report.velocity:
            lines.extend([
                "",
                "## Velocity Trends",
                "",
                "| Week | Completed | Specs |",
                "|------|-----------|-------|",
            ])

            for v in self.report.velocity[:12]:
                specs_list = ", ".join(v.spec_names[:3])
                if len(v.spec_names) > 3:
                    specs_list += f" (+{len(v.spec_names) - 3} more)"
                lines.append(f"| {v.week_key} | {v.specs_completed} | {specs_list} |")

            # Calculate average
            total_completed = sum(v.specs_completed for v in self.report.velocity)
            avg = total_completed / len(self.report.velocity) if self.report.velocity else 0
            lines.extend([
                "",
                f"**Average velocity**: {avg:.1f} specs/week",
            ])

        # Individual specs (top 10 most recent)
        if self.report.specs:
            completed_specs = [
                s for s in self.report.specs if s.completed_at
            ]
            completed_specs.sort(key=lambda s: s.completed_at, reverse=True)

            if completed_specs:
                lines.extend([
                    "",
                    "## Recent Completions",
                    "",
                    "| Spec | Completed | Cycle Time |",
                    "|------|-----------|------------|",
                ])

                for spec in completed_specs[:10]:
                    cycle = (
                        f"{spec.cycle_time_days} days"
                        if spec.cycle_time_days is not None
                        else "-"
                    )
                    lines.append(
                        f"| {spec.name} | {spec.completed_at} | {cycle} |"
                    )

        # Footer
        lines.extend([
            "",
            "---",
            "",
            f"*Report generated by doit analytics on {self.report.generated_at.strftime('%Y-%m-%d')}*",
        ])

        return "\n".join(lines)

    def export_json(self) -> str:
        """Export report as JSON.

        Returns:
            JSON formatted report string
        """
        return json.dumps(self.report.to_dict(), indent=2)

    def save(
        self,
        output_path: Optional[Path] = None,
        format_type: str = "markdown",
    ) -> Path:
        """Save report to file.

        Args:
            output_path: Path to save to (auto-generates if None)
            format_type: Export format (markdown or json)

        Returns:
            Path where report was saved

        Raises:
            ValueError: If format_type is not supported
            OSError: If file cannot be written
        """
        if format_type not in ("markdown", "json"):
            raise ValueError(f"Unsupported format: {format_type}")

        # Generate default path if not provided
        if output_path is None:
            reports_dir = self.report.project_root / ".doit" / "reports"
            reports_dir.mkdir(parents=True, exist_ok=True)

            timestamp = datetime.now().strftime("%Y-%m-%d")
            ext = "json" if format_type == "json" else "md"
            output_path = reports_dir / f"analytics-{timestamp}.{ext}"

        # Generate content
        if format_type == "json":
            content = self.export_json()
        else:
            content = self.export_markdown()

        # Ensure parent directory exists
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Write file
        output_path.write_text(content, encoding="utf-8")

        return output_path

    @classmethod
    def export_to_file(
        cls,
        report: AnalyticsReport,
        output_path: Optional[Path] = None,
        format_type: str = "markdown",
    ) -> Path:
        """Convenience method to export report directly.

        Args:
            report: The AnalyticsReport to export
            output_path: Path to save to (auto-generates if None)
            format_type: Export format (markdown or json)

        Returns:
            Path where report was saved
        """
        exporter = cls(report)
        return exporter.save(output_path, format_type)
